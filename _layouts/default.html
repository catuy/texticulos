<!doctype html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    {%- seo -%}
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://tonejs.github.io/build/Tone.js"></script>

    <link rel="icon" type="image/svg+xml" href="{{ site.baseurl }}/assets/images/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'IBM Plex Sans', sans-serif;
        }
    </style>
    {%- feed_meta -%}
    {%- if jekyll.environment == 'production' and site.google_analytics -%}
      {%- include google-analytics.html -%}
    {%- endif -%}
  </head>
  <body class="bg-[#f8f9fe] min-h-screen w-full">
    {%- include header.html -%}
    <main class="px-0">
        {{ content }}
    </main>
    {%- include footer.html -%}
    <script>
      function adjustImageSize(img) {
        if (img.naturalHeight > img.naturalWidth) {
          img.classList.add('h-screen', 'w-auto');
          img.classList.remove('w-2/3', 'h-auto');
        } else {
          img.classList.add('w-2/3', 'h-auto');
          img.classList.remove('h-screen', 'w-auto');
        }
      }

      function filterCategory(cat, element) {
        const rows = document.querySelectorAll('[data-category]');
        rows.forEach(row => {
          if (cat === 'Todos' || row.dataset.category === cat) {
            row.style.display = 'block';
          } else {
            row.style.display = 'none';
          }
        });
        // Update active link
        document.querySelectorAll('.category-link').forEach(link => {
          link.classList.remove('line-through');
        });
        if (element) {
          element.classList.add('line-through');
        }
      }

      // Piano setup with localStorage persistence
      let piano;
      let audioEnabled = false;
      let pianoLoaded = false;
      let audioContext = null;

      // Autoplay setup - always enabled
      let autoplayEnabled = true;
      let autoplayActive = false;
      let autoplayProjects = [];
      let autoplayTimeout = null;
      let inactivityTimeout = null;

      // localStorage helpers
      function getAudioPreference() {
        try {
          return localStorage.getItem('texticulos-audio') === 'enabled';
        } catch (e) {
          return false;
        }
      }

      function saveAudioPreference(enabled) {
        try {
          localStorage.setItem('texticulos-audio', enabled ? 'enabled' : 'disabled');
        } catch (e) {
          console.error('Could not save audio preference');
        }
      }

      // Autoplay localStorage helpers
      function getAutoplayPreference() {
        try {
          return localStorage.getItem('texticulos-autoplay') === 'enabled';
        } catch (e) {
          return false;
        }
      }

      function saveAutoplayPreference(enabled) {
        try {
          localStorage.setItem('texticulos-autoplay', enabled ? 'enabled' : 'disabled');
        } catch (e) {
          console.error('Could not save autoplay preference');
        }
      }

      function initPiano() {
        if (pianoLoaded) return;

        piano = new Tone.Sampler({
          urls: {
            A0: "A0.mp3",
            C1: "C1.mp3",
            "D#1": "Ds1.mp3",
            "F#1": "Fs1.mp3",
            A1: "A1.mp3",
            C2: "C2.mp3",
            "D#2": "Ds2.mp3",
            "F#2": "Fs2.mp3",
            A2: "A2.mp3",
            C3: "C3.mp3",
            "D#3": "Ds3.mp3",
            "F#3": "Fs3.mp3",
            A3: "A3.mp3",
            C4: "C4.mp3",
            "D#4": "Ds4.mp3",
            "F#4": "Fs4.mp3",
            A4: "A4.mp3",
            C5: "C5.mp3",
            "D#5": "Ds5.mp3",
            "F#5": "Fs5.mp3",
            A5: "A5.mp3",
            C6: "C6.mp3",
            "D#6": "Ds6.mp3",
            "F#6": "Fs6.mp3",
            A6: "A6.mp3",
            C7: "C7.mp3",
            "D#7": "Ds7.mp3",
            "F#7": "Fs7.mp3",
            A7: "A7.mp3",
            C8: "C8.mp3"
          },
          baseUrl: "https://tonejs.github.io/audio/salamander/",
          onload: () => {
            pianoLoaded = true;
          }
        }).toDestination();
      }

      function playRandomPianoNote() {
        if (!audioEnabled || !pianoLoaded) return;

        const pianoNotes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5'];
        const randomNote = pianoNotes[Math.floor(Math.random() * pianoNotes.length)];
        piano.triggerAttackRelease(randomNote, '8n');
      }

      // Auto-activate audio if user previously enabled it
      function tryActivateAudio() {
        // Only auto-activate if user previously enabled audio
        if (!getAudioPreference()) return;
        
        // Check if Tone context is already started
        if (Tone.context.state === 'running') return;
        
        // Try to start audio context
        Tone.start().then(() => {
          audioEnabled = true;
          audioContext = true;
          initPiano();
          updateAudioUI();
        }).catch((err) => {
          console.log('Audio activation failed:', err);
        });
      }

      function updateAudioUI() {
        // Update both mobile and desktop audio toggles
        const icons = [
          document.getElementById('audio-toggle'),
          document.getElementById('audio-toggle-mobile')
        ].filter(icon => icon !== null);

        icons.forEach(icon => {
          const audioOffIcon = icon.querySelector('.audio-off-icon');
          const audioOnIcon = icon.querySelector('.audio-on-icon');

          if (audioEnabled) {
            if (audioOffIcon) audioOffIcon.style.display = 'none';
            if (audioOnIcon) audioOnIcon.style.display = 'block';
            icon.title = 'Click to disable audio';
            icon.style.opacity = '1';
          } else {
            if (audioOffIcon) audioOffIcon.style.display = 'block';
            if (audioOnIcon) audioOnIcon.style.display = 'none';
            icon.title = 'Click to enable audio';
            icon.style.opacity = '0.6';
          }
        });
      }

      function toggleAudio() {
        if (audioEnabled) {
          // Disable audio
          audioEnabled = false;
          saveAudioPreference(false);
          updateAudioUI();
        } else {
          // Enable audio
          Tone.start().then(() => {
            audioEnabled = true;
            audioContext = true;
            saveAudioPreference(true);
            initPiano();
            updateAudioUI();
          }).catch(() => {
            // Show error on both mobile and desktop audio toggles
            const icons = [
              document.getElementById('audio-toggle'),
              document.getElementById('audio-toggle-mobile')
            ].filter(icon => icon !== null);

            icons.forEach(icon => {
              icon.textContent = 'error';
              icon.title = 'Audio failed to start';
            });
          });
        }
      }

      // Function to initialize audio UI and handlers
      function initializeAudioUI() {
        console.log('Initializing audio UI...');

        // Check which layout is visible (mobile or desktop)
        const isMobile = window.innerWidth < 768; // md breakpoint
        console.log('Is mobile layout:', isMobile);

        // Check for both mobile and desktop audio toggles
        let audioIcon;
        if (isMobile) {
          audioIcon = document.getElementById('audio-toggle-mobile');
          console.log('Looking for mobile audio toggle');
        } else {
          audioIcon = document.getElementById('audio-toggle');
          console.log('Looking for desktop audio toggle');
        }

        console.log('Audio icon found:', audioIcon ? audioIcon.id : 'none');
        if (!audioIcon) return;

        // Add direct click listener for debugging
        audioIcon.addEventListener('click', function(e) {
          console.log('Direct click listener triggered on:', this.id);
          e.stopPropagation();
        });

        // Restore audio state from localStorage if not already active
        if (!audioEnabled && getAudioPreference()) {
          audioEnabled = true;
          // Initialize piano if not loaded yet
          if (!pianoLoaded) {
            initPiano();
          }
        }

        // Update UI based on current actual state
        updateAudioUI();

        // Remove old listener if exists
        const newIcon = audioIcon.cloneNode(true);
        audioIcon.parentNode.replaceChild(newIcon, audioIcon);

        // Attach fresh toggle handler
        newIcon.addEventListener('click', toggleAudio);
      }

      // Autoplay functions
      function collectAutoplayProjects() {
        autoplayProjects = [];
        const projectImages = document.querySelectorAll('a[data-category] img');
        projectImages.forEach(img => {
          autoplayProjects.push(img);
        });
      }

      function showRandomProject() {
        // Ensure autoplayProjects is initialized
        if (autoplayProjects.length === 0) {
          collectAutoplayProjects();
        }
        if (autoplayProjects.length === 0) return;

        // Hide all images and remove underlines first
        autoplayProjects.forEach(img => {
          img.style.opacity = '0';
          // Remove underline from parent link
          const link = img.closest('a');
          if (link) {
            link.classList.remove('underline');
          }
        });

        // Show random project image
        const randomIndex = Math.floor(Math.random() * autoplayProjects.length);
        const randomImage = autoplayProjects[randomIndex];
        randomImage.style.opacity = '1';

        // Add underline to the corresponding link (imitate hover)
        const link = randomImage.closest('a');
        if (link) {
          link.classList.add('underline');
        }

        // Play sound
        playRandomPianoNote();

        // Schedule next random show (ultra fast: 0-1 seconds)
        const randomDelay = Math.random() * 1000; // 0-1 seconds
        autoplayTimeout = setTimeout(showRandomProject, randomDelay);
      }

      function showSpecificProject(projectLink) {
        // Ensure autoplayProjects is initialized
        if (autoplayProjects.length === 0) {
          collectAutoplayProjects();
        }

        // Remove all underlines first
        autoplayProjects.forEach(img => {
          const link = img.closest('a');
          if (link) {
            link.classList.remove('underline');
          }
        });

        // Find the image for this specific project
        const projectImage = projectLink.querySelector('img');
        if (!projectImage) return;

        // Hide all images first
        autoplayProjects.forEach(img => {
          img.style.opacity = '0';
        });

        // Show this specific image
        projectImage.style.opacity = '1';

        // Add underline to this link
        projectLink.classList.add('underline');

        // Play sound
        playRandomPianoNote();

        // Clear current timeout - don't restart autoplay here, let inactivity timer handle it
        if (autoplayTimeout) {
          clearTimeout(autoplayTimeout);
          autoplayTimeout = null;
        }
      }

      function startAutoplay() {
        if (autoplayActive) return;

        autoplayActive = true;
        collectAutoplayProjects();

        if (autoplayProjects.length > 0) {
          // Start immediately with first random project
          showRandomProject();
        }
      }

      function stopAutoplay() {
        autoplayActive = false;
        if (autoplayTimeout) {
          clearTimeout(autoplayTimeout);
          autoplayTimeout = null;
        }

        // Ensure autoplayProjects is initialized before trying to use it
        if (autoplayProjects.length === 0) {
          collectAutoplayProjects();
        }

        // Hide all autoplay images and remove underlines
        autoplayProjects.forEach(img => {
          img.style.opacity = '0';
          // Remove underline from parent link
          const link = img.closest('a');
          if (link) {
            link.classList.remove('underline');
          }
        });
      }

      function updateAutoplayUI() {
        const icon = document.getElementById('autoplay-toggle');
        if (!icon) return;

        const autoplayOnIcon = icon.querySelector('.autoplay-on-icon');
        const autoplayOffIcon = icon.querySelector('.autoplay-off-icon');

        if (autoplayEnabled) {
          if (autoplayOnIcon) autoplayOnIcon.style.display = 'block';
          if (autoplayOffIcon) autoplayOffIcon.style.display = 'none';
          icon.title = 'Click to disable autoplay';
          icon.style.opacity = '1';
        } else {
          if (autoplayOnIcon) autoplayOnIcon.style.display = 'none';
          if (autoplayOffIcon) autoplayOffIcon.style.display = 'block';
          icon.title = 'Click to enable autoplay';
          icon.style.opacity = '0.6';
        }
      }

      function toggleAutoplay() {
        if (autoplayEnabled) {
          // Disable autoplay
          autoplayEnabled = false;
          saveAutoplayPreference(false);
          stopAutoplay();
          autoplayPausedByUser = true;
          updateAutoplayUI();
        } else {
          // Enable autoplay
          autoplayEnabled = true;
          saveAutoplayPreference(true);
          updateAutoplayUI();
          // Start autoplay if not already active and user hasn't interacted
          if (!autoplayActive && !autoplayPausedByUser) {
            startAutoplay();
          }
        }
      }

      // Reset inactivity timer
      function resetInactivityTimer() {
        if (inactivityTimeout) {
          clearTimeout(inactivityTimeout);
        }
        inactivityTimeout = setTimeout(() => {
          // After 10 seconds of inactivity, resume autoplay if enabled
          // Reset the paused flag so autoplay can start again
          autoplayPausedByUser = false;
          if (autoplayEnabled && !autoplayActive) {
            startAutoplay();
          }
        }, 10000); // 10 seconds
      }

      // Function to initialize autoplay UI and handlers
      function initializeAutoplayUI() {
        const autoplayIcon = document.getElementById('autoplay-toggle');
        if (!autoplayIcon) return;

        // Restore autoplay state from localStorage, but default to ENABLED if no preference
        autoplayEnabled = getAutoplayPreference() !== false; // Default to true

        // Update UI based on current state
        updateAutoplayUI();

        // Remove old listener if exists
        const newIcon = autoplayIcon.cloneNode(true);
        autoplayIcon.parentNode.replaceChild(newIcon, autoplayIcon);

        // Attach fresh toggle handler
        newIcon.addEventListener('click', toggleAutoplay);
      }

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize audio UI
        initializeAudioUI();



        // Add hover sound and manual control to clickable projects
        const projectLinks = document.querySelectorAll('a[data-category]');
        projectLinks.forEach(link => {
          link.addEventListener('mouseenter', function() {
            // Stop autoplay when hovering
            if (autoplayActive) {
              stopAutoplay();
            }

            // Reset inactivity timer
            resetInactivityTimer();

            // Show this specific project manually
            showSpecificProject(this);

            // Also show hover images for desktop
            if (window.innerWidth >= 768) { // Desktop breakpoint
              const hoverImages = this.querySelectorAll('img');
              hoverImages.forEach(img => {
                if (img.classList.contains('group-hover:opacity-100')) {
                  img.style.opacity = '1';
                }
              });
            }
          });

          // Add mouseleave to hide image and restart timer
          link.addEventListener('mouseleave', function() {
            // Hide the image for this project when leaving hover
            const projectImage = this.querySelector('img');
            if (projectImage) {
              projectImage.style.opacity = '0';
            }

            // Remove underline from this link
            this.classList.remove('underline');

            // Also hide hover images for desktop
            const hoverImages = this.querySelectorAll('img');
            hoverImages.forEach(img => {
              if (img.classList.contains('group-hover:opacity-100')) {
                img.style.opacity = '0';
              }
            });

            // Reset inactivity timer
            resetInactivityTimer();
          });
        });

        // IMPORTANT: Activate audio when clicking on navigation links
        // This ensures audio is ready BEFORE navigating to the next page
        const allLinks = document.querySelectorAll('a[href]');
        allLinks.forEach(link => {
          link.addEventListener('click', function(e) {
            // Only activate if audio preference is enabled
            if (getAudioPreference() && !audioEnabled && !audioContext) {
              tryActivateAudio();
            }

            // First click anywhere stops autoplay permanently
            if (!userHasInteracted) {
              userHasInteracted = true;
              stopAutoplay();
              autoplayPausedByUser = true;
            }
          }, true);
        });

        // Permanent listeners for auto-activation (don't remove them)
        // Only activates if user previously enabled audio
        document.addEventListener('click', tryActivateAudio, true);
        document.addEventListener('keydown', tryActivateAudio, true);
        document.addEventListener('touchstart', tryActivateAudio, true);

        // Start inactivity timer initially
        resetInactivityTimer();
      });

      // RANDOM TEXT SPACING EFFECT - Comment out this entire block to disable
      /*
      function addRandomSpacesToText() {
        // Configuration - adjust these values
        const maxSpacesPerWord = 3; // Maximum spaces to insert per word
        const spaceProbability = 0.3; // Probability (0-1) of inserting a space between characters

        function processTextNode(node) {
          if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
            // Skip if parent is one of these tags
            const parentTag = node.parentNode.tagName;
            if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'TITLE'].includes(parentTag)) {
              return;
            }

            const originalText = node.textContent;
            let newText = '';

            // Process each word separately
            const words = originalText.split(/(\s+)/);

            for (let word of words) {
              if (word.trim()) { // Only process non-whitespace
                let spacedWord = '';

                for (let i = 0; i < word.length; i++) {
                  spacedWord += word[i];

                  // Add random thin spaces between characters (but not at the end)
                  if (i < word.length - 1 && Math.random() < spaceProbability) {
                    const numSpaces = Math.floor(Math.random() * maxSpacesPerWord) + 1;
                    spacedWord += '\u2009'.repeat(numSpaces); // Thin space (narrower than regular space)
                  }
                }

                newText += spacedWord;
              } else {
                newText += word; // Preserve whitespace
              }
            }

            node.textContent = newText;
          }
        }

        function walkTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            processTextNode(node);
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            // Skip certain elements
            const tagName = node.tagName;
            if (!['SCRIPT', 'STYLE', 'NOSCRIPT', 'IFRAME', 'OBJECT', 'EMBED'].includes(tagName)) {
              for (let child of node.childNodes) {
                walkTextNodes(child);
              }
            }
          }
        }

        // Apply to entire document
        walkTextNodes(document.body);
      }

      // Apply the effect after page loads
      document.addEventListener('DOMContentLoaded', function() {
        // Small delay to ensure all content is loaded
        setTimeout(addRandomSpacesToText, 100);
      });
      */ 
      // END RANDOM TEXT SPACING EFFECT

      // SPA-like navigation for smooth audio persistence
      function initSPANavigation() {
        // Get current origin for checking internal links
        const currentOrigin = window.location.origin;

        // Function to reinitialize page-specific functionality after content load
        function reinitializePageEvents() {
          // Re-initialize audio UI and toggle
          initializeAudioUI();



          // Re-apply hover sounds to project links
          const projectLinks = document.querySelectorAll('a[data-category]');
          projectLinks.forEach(link => {
            link.addEventListener('mouseenter', playRandomPianoNote);
          });

          // Re-apply text spacing effect
          setTimeout(addRandomSpacesToText, 50);

          // Re-attach SPA navigation to new links
          attachSPAListeners();
        }

        // Function to load a page via AJAX
        function loadPage(url) {
          console.log('Loading page:', url);
          fetch(url)
            .then(response => {
              console.log('Fetch response status:', response.status);
              return response.text();
            })
            .then(html => {
              console.log('HTML received, length:', html.length);
              // Parse the HTML
              const parser = new DOMParser();
              const doc = parser.parseFromString(html, 'text/html');

              // Check current and new page types
              const currentHasCustomHeader = document.querySelector('body > div.relative');
              const newBody = doc.querySelector('body');
              const newHasCustomHeader = doc.querySelector('body > div.relative');

              console.log('Current has custom header:', currentHasCustomHeader);
              console.log('New has custom header:', newHasCustomHeader);

              // Always replace entire body if transitioning between different layouts
              // or if current page is detail (to clean up images/videos)
              if (newHasCustomHeader || currentHasCustomHeader) {
                console.log('Replacing entire body content');
                // Replace entire body content
                const currentBody = document.querySelector('body');

                // Replace body content
                currentBody.innerHTML = newBody.innerHTML;

                // Update page title
                const newTitle = doc.querySelector('title');
                if (newTitle) {
                  document.title = newTitle.textContent;
                }

                // Scroll to top
                window.scrollTo(0, 0);

                // Reinitialize events (don't re-execute scripts to avoid variable redeclaration errors)
                reinitializePageEvents();

              } else {
                console.log('Replacing main content only');
                // Both are standard pages: replace just main content (more efficient)
                const newMain = doc.querySelector('main');
                const currentMain = document.querySelector('main');

                if (newMain && currentMain) {
                  // Replace main content
                  currentMain.innerHTML = newMain.innerHTML;

                  // Update page title
                  const newTitle = doc.querySelector('title');
                  if (newTitle) {
                    document.title = newTitle.textContent;
                  }

                  // Scroll to top
                  window.scrollTo(0, 0);

                  // Reinitialize events for new content
                  reinitializePageEvents();
                }
              }
            })
            .catch(error => {
              console.error('Error loading page:', error);
              // Fallback to normal navigation
              window.location.href = url;
            });
        }

        // Function to attach SPA listeners to links
        function attachSPAListeners() {
          const links = document.querySelectorAll('a[href]');
          
          links.forEach(link => {
            // Check if it's an internal link
            const href = link.getAttribute('href');
            
            // Skip if already has SPA listener
            if (link.hasAttribute('data-spa-attached')) return;
            
            // Skip links with onclick (category filters)
            if (link.hasAttribute('onclick')) return;
            
            // Only handle internal links (same origin, not external, not anchors, not files)
            if (href && 
                !href.startsWith('http') && 
                !href.startsWith('#') && 
                !href.startsWith('mailto:') &&
                !href.startsWith('tel:') &&
                !href.endsWith('.pdf') &&
                !href.endsWith('.zip')) {
              
              link.setAttribute('data-spa-attached', 'true');
              
              link.addEventListener('click', function(e) {
                // Don't prevent if it's audio toggle or external link
                if (this.id === 'audio-toggle' || this.id === 'audio-toggle-mobile') return;

                e.preventDefault();
                
                const targetUrl = this.href;
                
                // Update browser history
                history.pushState({}, '', targetUrl);
                
                // Load the new page
                loadPage(targetUrl);
              });
            }
          });
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(e) {
          console.log('Popstate event fired, loading:', window.location.href);
          loadPage(window.location.href);
        });

        // Push initial state to history for proper back button support
        if (!window.history.state) {
          history.replaceState({ url: window.location.href }, '', window.location.href);
        }

        // Initialize on page load
        attachSPAListeners();
      }

      // Initialize SPA navigation when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        initSPANavigation();
      });

      // Start autoplay immediately when script loads (ultra fast)
      if (autoplayEnabled && window.location.pathname === '/' && !userHasInteracted) {
        // Use requestAnimationFrame for immediate execution after script load
        requestAnimationFrame(() => {
          startAutoplay();
        });
      }

    </script>
  </body>
</html>
