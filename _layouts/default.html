<!doctype html>
<html lang="{{ site.lang | default: "en-US" }}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    {%- seo -%}
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://tonejs.github.io/build/Tone.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'IBM Plex Sans', sans-serif;
        }
    </style>
    {%- feed_meta -%}
    {%- if jekyll.environment == 'production' and site.google_analytics -%}
      {%- include google-analytics.html -%}
    {%- endif -%}
  </head>
  <body class="bg-[#f8f9fe] min-h-screen w-full">
    {%- include header.html -%}
    <main class="px-0">
        {{ content }}
    </main>
    {%- include footer.html -%}
    <script>
      function adjustImageSize(img) {
        if (img.naturalHeight > img.naturalWidth) {
          img.classList.add('h-screen', 'w-auto');
          img.classList.remove('w-2/3', 'h-auto');
        } else {
          img.classList.add('w-2/3', 'h-auto');
          img.classList.remove('h-screen', 'w-auto');
        }
      }

      function filterCategory(cat) {
        const rows = document.querySelectorAll('[data-category]');
        rows.forEach(row => {
          if (cat === 'Todos' || row.dataset.category === cat) {
            row.style.display = 'block';
          } else {
            row.style.display = 'none';
          }
        });
        // Update active link
        document.querySelectorAll('.category-link').forEach(link => {
          link.classList.remove('line-through');
        });
        event.target.classList.add('line-through');
      }

      // Piano setup - Audio ALWAYS ON by default
      let piano;
      let audioEnabled = false; // Will be set to true on first interaction
      let pianoLoaded = false;
      let audioActivated = false;

      function initPiano() {
        if (pianoLoaded) return;

        piano = new Tone.Sampler({
          urls: {
            A0: "A0.mp3",
            C1: "C1.mp3",
            "D#1": "Ds1.mp3",
            "F#1": "Fs1.mp3",
            A1: "A1.mp3",
            C2: "C2.mp3",
            "D#2": "Ds2.mp3",
            "F#2": "Fs2.mp3",
            A2: "A2.mp3",
            C3: "C3.mp3",
            "D#3": "Ds3.mp3",
            "F#3": "Fs3.mp3",
            A3: "A3.mp3",
            C4: "C4.mp3",
            "D#4": "Ds4.mp3",
            "F#4": "Fs4.mp3",
            A4: "A4.mp3",
            C5: "C5.mp3",
            "D#5": "Ds5.mp3",
            "F#5": "Fs5.mp3",
            A5: "A5.mp3",
            C6: "C6.mp3",
            "D#6": "Ds6.mp3",
            "F#6": "Fs6.mp3",
            A6: "A6.mp3",
            C7: "C7.mp3",
            "D#7": "Ds7.mp3",
            "F#7": "Fs7.mp3",
            A7: "A7.mp3",
            C8: "C8.mp3"
          },
          baseUrl: "https://tonejs.github.io/audio/salamander/",
          onload: () => {
            pianoLoaded = true;
          }
        }).toDestination();
      }

      function playRandomPianoNote() {
        if (!audioEnabled || !pianoLoaded) return;

        const pianoNotes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5'];
        const randomNote = pianoNotes[Math.floor(Math.random() * pianoNotes.length)];
        piano.triggerAttackRelease(randomNote, '8n');
      }

      // Auto-activate audio on first user interaction (AGGRESSIVE)
      function tryActivateAudio() {
        if (audioActivated) return;

        Tone.start().then(() => {
          audioEnabled = true;
          audioActivated = true;
          initPiano();
          
          // Remove all listeners after successful activation
          document.removeEventListener('mousemove', tryActivateAudio);
          document.removeEventListener('click', tryActivateAudio);
          document.removeEventListener('scroll', tryActivateAudio);
          document.removeEventListener('keydown', tryActivateAudio);
          document.removeEventListener('touchstart', tryActivateAudio);
        }).catch(() => {
          // Silently fail, will retry on next interaction
        });
      }

      function toggleAudio() {
        const icon = document.getElementById('audio-toggle');

        if (audioEnabled) {
          // Disable audio (only for current session)
          audioEnabled = false;
          icon.textContent = 'sonido off';
          icon.title = 'Click to enable audio';
          icon.style.opacity = '0.6';
        } else {
          // Enable audio
          Tone.start().then(() => {
            audioEnabled = true;
            audioActivated = true;
            initPiano();
            icon.textContent = 'sonido on';
            icon.title = 'Click to disable audio';
            icon.style.opacity = '1';
          }).catch(() => {
            icon.textContent = 'error';
            icon.title = 'Audio Failed';
          });
        }
      }

      // Add event listeners
      document.addEventListener('DOMContentLoaded', function() {
        // Set UI to always show "sonido on" by default
        const audioIcon = document.getElementById('audio-toggle');
        audioIcon.textContent = 'sonido on';
        audioIcon.title = 'Click to disable audio';
        audioIcon.style.opacity = '1';
        audioIcon.addEventListener('click', toggleAudio);

        // Add hover sound to clickable projects
        const projectLinks = document.querySelectorAll('a[data-category]');
        projectLinks.forEach(link => {
          link.addEventListener('mouseenter', playRandomPianoNote);
        });

        // AGGRESSIVE auto-activation: listen to MULTIPLE events
        // Audio will activate on the FIRST of any of these interactions
        document.addEventListener('mousemove', tryActivateAudio, { once: false });
        document.addEventListener('click', tryActivateAudio, { once: false });
        document.addEventListener('scroll', tryActivateAudio, { once: false, passive: true });
        document.addEventListener('keydown', tryActivateAudio, { once: false });
        document.addEventListener('touchstart', tryActivateAudio, { once: false });

        // Try to activate immediately (will fail due to browser policy, but worth trying)
        tryActivateAudio();
      });

      // RANDOM TEXT SPACING EFFECT - Comment out this entire block to disable
      function addRandomSpacesToText() {
        // Configuration - adjust these values
        const maxSpacesPerWord = 3; // Maximum spaces to insert per word
        const spaceProbability = 0.3; // Probability (0-1) of inserting a space between characters

        function processTextNode(node) {
          if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
            // Skip if parent is one of these tags
            const parentTag = node.parentNode.tagName;
            if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'TITLE'].includes(parentTag)) {
              return;
            }

            const originalText = node.textContent;
            let newText = '';

            // Process each word separately
            const words = originalText.split(/(\s+)/);

            for (let word of words) {
              if (word.trim()) { // Only process non-whitespace
                let spacedWord = '';

                for (let i = 0; i < word.length; i++) {
                  spacedWord += word[i];

                  // Add random spaces between characters (but not at the end)
                  if (i < word.length - 1 && Math.random() < spaceProbability) {
                    const numSpaces = Math.floor(Math.random() * maxSpacesPerWord) + 1;
                    spacedWord += ' '.repeat(numSpaces);
                  }
                }

                newText += spacedWord;
              } else {
                newText += word; // Preserve whitespace
              }
            }

            node.textContent = newText;
          }
        }

        function walkTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            processTextNode(node);
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            // Skip certain elements
            const tagName = node.tagName;
            if (!['SCRIPT', 'STYLE', 'NOSCRIPT', 'IFRAME', 'OBJECT', 'EMBED'].includes(tagName)) {
              for (let child of node.childNodes) {
                walkTextNodes(child);
              }
            }
          }
        }

        // Apply to entire document
        walkTextNodes(document.body);
      }

      // Apply the effect after page loads
      document.addEventListener('DOMContentLoaded', function() {
        // Small delay to ensure all content is loaded
        setTimeout(addRandomSpacesToText, 100);
      });
      // END RANDOM TEXT SPACING EFFECT

    </script>
  </body>
</html>
